<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>360 Viewer con Stages</title>
  <style>
    html,body{margin:0;height:100%;background:#000;}
    #app{width:100%;height:100%;position:relative;overflow:hidden;}
    canvas{display:block;}
  </style>
</head>
<body>
<div id="app"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
  // =============== CONFIG ===============
  const STAGES = [
    {
      photo:"recorrido01.jpg",
      marker:{src:"tembetari.png", yaw:0, pitch:5, scale:[500,450]},
      transition:"transicion01.mp4",
      forward:{yaw:-25, pitch:0},
      audio: "monte.mp3"
    },
    {
      photo:"recorrido02.jpg",
      marker:{src:"tembetari.png", yaw:0, pitch:0, scale:[300,300]},
      transition:"transicion02.mp4",
      forward:{yaw:180, pitch:0},
      audio: "monte.mp3"
    }
  ];
  let currentStageIndex = 0;

  // Edge-look params
  const MOUSE_LOOK = {
    deadzone: 0.12,                 // radio central sin movimiento (0..1)
    maxSpeed: { yaw: 80, pitch: 50 }, // grados/seg máx cerca del borde
    damping: 0.12                   // suavizado de velocidad (0..1)
  };

  // =============== BASICS ===============
  const root = document.getElementById("app");
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(root.clientWidth, root.clientHeight);
  root.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, root.clientWidth / root.clientHeight, 0.1, 2000);
  camera.position.set(0,0,0.1);

  const pano = new THREE.Group();
  scene.add(pano);

  const sphereGeo = new THREE.SphereGeometry(500,64,48);
  sphereGeo.scale(-1,1,1);
  const sphereMat = new THREE.MeshBasicMaterial();
  const sphere = new THREE.Mesh(sphereGeo, sphereMat);
  pano.add(sphere);
  pano.scale.set(2,2,2);

  const anchor = new THREE.Object3D();
  pano.add(anchor);

  // uniforms compartidos
  const uniforms = {
    uTexture:{value:null},
    uTime:{value:0},
    uGlitch:{value:1.0}
  };

  const markerMat = new THREE.ShaderMaterial({
    uniforms,
    transparent:true,
    side:THREE.DoubleSide,
    vertexShader:`
      varying vec2 vUv;
      void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }
    `,
    fragmentShader:`
      uniform sampler2D uTexture;
      uniform float uTime;
      uniform float uGlitch;
      varying vec2 vUv;
      float rand(vec2 co){ return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453); }
      void main(){
        vec2 uv=vUv;
        vec4 tex=texture2D(uTexture,uv);
        float line=floor(uv.y*200.0);
        float offset=rand(vec2(line,floor(uTime*30.0)))-0.5;
        vec2 glitchUV=uv; glitchUV.x+=offset*0.3;
        vec4 texGlitch=texture2D(uTexture,glitchUV);
        float gray=dot(texGlitch.rgb,vec3(0.3,0.59,0.11));
        vec3 greenish=vec3(0.0,gray,0.0);
        float scan=sin(uv.y*800.0+uTime*20.0)*0.1;
        greenish+=vec3(0.0,scan,0.0);
        vec4 glitchColor=vec4(greenish,texGlitch.a);
        gl_FragColor=mix(tex,glitchColor,uGlitch);
      }
    `
  });

  // estado orientación (grados)
  let lon = 0, lat = 0;

  function faceInwardNoRoll(obj){
    obj.up.set(0,1,0);
    obj.lookAt(0,0,0);
    obj.rotateY(Math.PI);
  }

  let marker;
  function placeMarker(conf){
    if (marker) anchor.remove(marker);
    marker = new THREE.Mesh(
      new THREE.PlaneGeometry(conf.scale[0], conf.scale[1]),
      markerMat
    );
    anchor.add(marker);

    uniforms.uTexture.value = new THREE.TextureLoader().load(conf.src);

    const theta = THREE.MathUtils.degToRad(90 - conf.pitch);
    const phi   = THREE.MathUtils.degToRad(conf.yaw);
    const r = 400;
    anchor.position.set(
      r * Math.sin(theta) * Math.cos(phi),
      r * Math.cos(theta),
      r * Math.sin(theta) * Math.sin(phi)
    );

    faceInwardNoRoll(anchor);
    marker.position.set(0,0,1);
  }

  function loadStage(i){
    const st = STAGES[i];
    const tex = new THREE.TextureLoader().load(st.photo);
    tex.colorSpace = THREE.SRGBColorSpace;
    sphere.material.map = tex;
    sphere.material.needsUpdate = true;

    placeMarker(st.marker);

    uniforms.uGlitch.value = 1.0;

    if (st.forward){ lon = st.forward.yaw; lat = st.forward.pitch; }

    // audio
    if (st.audio){
      if (window.currentAudio){
        window.currentAudio.pause();
        window.currentAudio = null;
      }
      const audio = new Audio(st.audio);
      audio.loop = true;
      audio.volume = 0.5;
      audio.play();
      window.currentAudio = audio;
    }
  }
  loadStage(currentStageIndex);

  // =============== EDGE-LOOK (mouse sin click) ===============
  // mouseNDC: [-1,1] con (0,0) al centro del canvas
  const mouseNDC = new THREE.Vector2(0,0);
  renderer.domElement.addEventListener("mousemove", (e)=>{
    const rect = renderer.domElement.getBoundingClientRect();
    mouseNDC.x = ((e.clientX - rect.left) / rect.width)  * 2 - 1;
    mouseNDC.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
  });
  renderer.domElement.addEventListener("mouseleave", ()=>{
    mouseNDC.set(0,0); // al salir, detener
  });

  // suavizado de velocidad
  let velLon = 0, velLat = 0;

  function smoothstep01(x){ x = Math.min(Math.max(x,0),1); return x*x*(3-2*x); }

  function targetVelFromMouse(){
    // aplicar deadzone
    const dz = MOUSE_LOOK.deadzone;
    function axis(a){
      if (Math.abs(a) <= dz) return 0;
      const t = (Math.abs(a) - dz) / (1 - dz);         // 0..1
      const s = smoothstep01(t);                        // curva suave
      return Math.sign(a) * s;                          // -1..1 (fuera de zona muerta)
    }
    const ax = axis(mouseNDC.x);
    const ay = axis(mouseNDC.y);

    // nota: mover mouse a la derecha => disminuir lon (como tu drag original)
    const vx = ax * MOUSE_LOOK.maxSpeed.yaw;   // deg/sec sobre lon
    const vy =  ay * MOUSE_LOOK.maxSpeed.pitch; // deg/sec sobre lat
    return { vx, vy };
  }

  // =============== CLICK HANDLING ===============
  const raycaster = new THREE.Raycaster();
  const ndc = new THREE.Vector2();
  function screenToNDC(ev){
    const rect = renderer.domElement.getBoundingClientRect();
    const cx = (ev.clientX - rect.left) / rect.width;
    const cy = (ev.clientY - rect.top)  / rect.height;
    ndc.set(cx * 2 - 1, -(cy * 2 - 1));
  }

  let isAutoLook = false; // para bloquear edge-look durante animaciones

  renderer.domElement.addEventListener("click", ev=>{
    screenToNDC(ev);
    raycaster.setFromCamera(ndc, camera);
    const hits = raycaster.intersectObject(marker, true);
    if (!hits.length) return;

    // glitch off
    const duration = 1500, start = performance.now(), startVal = uniforms.uGlitch.value;
    function animateGlitch(){
      const t = (performance.now() - start) / duration;
      uniforms.uGlitch.value = THREE.MathUtils.lerp(startVal, 0, Math.min(t,1));
      if (t < 1) requestAnimationFrame(animateGlitch);
      else smoothLookForward();
    }
    animateGlitch();
  });

  function smoothLookForward(){
    const fwd = STAGES[currentStageIndex].forward || {yaw:0, pitch:0};
    const targetLon = fwd.yaw, targetLat = fwd.pitch;
    const startLon = lon,   startLat = lat;
    const duration = 2000, start = performance.now();
    isAutoLook = true;

    function anim(){
      const t = Math.min((performance.now() - start) / duration, 1);
      lon = THREE.MathUtils.lerp(startLon, targetLon, t);
      lat = THREE.MathUtils.lerp(startLat, targetLat, t);
      if (t < 1) requestAnimationFrame(anim);
      else { isAutoLook = false; playTransitionVideo(); }
    }
    anim();
  }

  function playTransitionVideo(){
    const stage = STAGES[currentStageIndex];
    if (!stage.transition){ nextStage(); return; }

    const video = document.createElement("video");
    video.src = stage.transition;
    video.autoplay = true; video.playsInline = true;
    Object.assign(video.style, {
      width:"100%", height:"100%", position:"absolute",
      top:0,left:0, objectFit:"cover"
    });
    root.appendChild(video);
    video.onended = () => { root.removeChild(video); nextStage(); };
  }

  function nextStage(){
    currentStageIndex = (currentStageIndex + 1) % STAGES.length;
    loadStage(currentStageIndex);
  }

  // =============== LOOP ===============
  let last = performance.now();
  renderer.setAnimationLoop(()=>{
    const now = performance.now();
    const dt  = Math.min((now - last) / 1000, 0.05); // clamp dt
    last = now;

    uniforms.uTime.value = now * 0.001;

    // Edge-look: integra velocidades con suavizado
    if (!isAutoLook){
      const { vx, vy } = targetVelFromMouse();
      velLon += (vx - velLon) * MOUSE_LOOK.damping;
      velLat += (vy - velLat) * MOUSE_LOOK.damping;

      lon += velLon * dt;
      lat += velLat * dt;
      lat = Math.max(-85, Math.min(85, lat));
    } else {
      // durante auto-look, relajá velocidades a 0 para evitar tirones al terminar
      velLon += (0 - velLon) * MOUSE_LOOK.damping;
      velLat += (0 - velLat) * MOUSE_LOOK.damping;
    }

    const phi = THREE.MathUtils.degToRad(90 - lat);
    const theta = THREE.MathUtils.degToRad(lon);
    camera.lookAt(
      500 * Math.sin(phi) * Math.cos(theta),
      500 * Math.cos(phi),
      500 * Math.sin(phi) * Math.sin(theta)
    );
    renderer.render(scene, camera);
  });

  window.addEventListener("resize", ()=>{
    camera.aspect = root.clientWidth / root.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(root.clientWidth, root.clientHeight);
  });
})();
</script>
</body>
</html>
